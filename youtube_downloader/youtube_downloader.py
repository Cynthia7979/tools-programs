import sys
import os
import threading
import logging
import glob
import time
from pytube import Playlist, YouTube
from pytube.exceptions import VideoUnavailable
from pytube.helpers import safe_filename
from pytube.cli import on_progress
from typing import Iterable

SAVE_DIR = "./downloads" if len(sys.argv) <= 2 else sys.argv[2]
ALWAYS_SKIP_ON_EXISTS = True
MAX_THREADS = 5

def main():
    global logger_main
    logger_main = logging.getLogger('YoutubeDownloader')
    logger_main_sh = logging.StreamHandler(sys.stdout)
    fmtstr_main = "%(asctime)s (:%(relativeCreated)d) [%(levelname)s] %(name)s.%(funcName)s:%(lineno)d (%(threadName)s): %(message)s"
    datefmt_main = '%H:%M:%S'
    formatter = logging.Formatter(fmtstr_main, datefmt_main)
    logger_main_sh.setFormatter(formatter)
    logger_main.addHandler(logger_main_sh)
    logger_main.setLevel(logging.DEBUG)
    logger_main.info('Starting youtube_downloader.py...')

    try:
        playlist = Playlist(sys.argv[1])
        if input(f"About to pull videos from {playlist.title} into {SAVE_DIR}. Continue? (Y/n) ").lower() == "n":
            return
        if not os.path.exists(SAVE_DIR):
            os.mkdir(SAVE_DIR)
        
        videos = retrieve_videos(playlist)

        for i, video in enumerate(videos):
            if threading.active_count() >= MAX_THREADS + 1:  # Main thread counts as one
                time.sleep(10)
                continue
            else:
                video_thread = threading.Thread(
                    target=download_video, 
                    args=(video, SAVE_DIR),
                    name=f'{i} {video.title[:10]}',
                    daemon=True
                )
                video_thread.start()
            
    except Exception as e:
        logger_main.error(f"Critical Error: {e}. Program exiting.")
        print()  # Separate log messages and exception
        raise e
    
    logger_main.info('Finished running. Exiting...')

def retrieve_videos(playlist: Playlist, desc=True) -> Iterable[YouTube]:
    return list(playlist.videos)[::(-1 if desc else 1)]

def download_video(video: YouTube, save_dir: str, res='highest'):
    # Checking before retrieving streams to optimize efficiency
    if glob.glob(os.path.join(save_dir, safe_filename(video.title)+'.*')):
        if ALWAYS_SKIP_ON_EXISTS or input(f'"{os.path.basename(save_dir)} already exists, overwrite? (y/N) "').lower() != 'y':
            logger_main.debug(f'{video.title} already exists. Skipping to the next video...')
    try:
        video.register_on_progress_callback(on_progress)
        stream = video.streams.get_highest_resolution()
        logger_main.debug(f'Downloading {video.title}...')
        stream.download(save_dir, skip_existing=False)  # Filename is automatically generated by stream
    except VideoUnavailable:
        logger_main.warning(f'{video.title} not found. Skipping to the next video...')
        return
    except Exception as e:
        logger_main.error(f'Download aborted! Critical error when downloading {video.title}: {e}')
        return
    logger_main.info(f'Finished downloading {video.title}!')

if __name__ == "__main__":
    main()