import sys
import os
import threading
import logging
import glob
import time
from pytube import Playlist, YouTube
from pytube.exceptions import VideoUnavailable
from pytube.helpers import safe_filename
from typing import Iterable

SAVE_DIR = "./downloads" if len(sys.argv) <= 2 else sys.argv[2]
ALWAYS_SKIP_ON_EXISTS = True
CHECK_FILE_INTEGRITY = True
MAX_THREADS = 5
DOWNLOAD_BACK_TO_FRONT = True

def main():
    global logger_main
    logger_main = logging.getLogger('YoutubeDownloader')
    logger_main_sh = logging.StreamHandler(sys.stdout)
    fmtstr_main = "%(asctime)s (:%(relativeCreated)d) [%(levelname)s] %(name)s.%(funcName)s:%(lineno)d (%(threadName)s): %(message)s"
    datefmt_main = '%H:%M:%S'
    formatter = logging.Formatter(fmtstr_main, datefmt_main)
    logger_main_sh.setFormatter(formatter)
    logger_main.addHandler(logger_main_sh)
    logger_main.setLevel(logging.DEBUG)
    logger_main.info('Starting youtube_downloader.py...')

    try:
        playlist = Playlist(sys.argv[1])
        if input(f"About to download videos from {playlist.title} ({playlist.length} videos) into {SAVE_DIR}. Continue? (Y/n) ").lower() == "n":
            return
        if not os.path.exists(SAVE_DIR):
            os.mkdir(SAVE_DIR)
        
        videos = retrieve_videos(playlist, DOWNLOAD_BACK_TO_FRONT)

        for i, video in enumerate(videos):
            while threading.active_count() >= MAX_THREADS + 1:  # Main thread counts as one
                time.sleep(5)
            else:
                video_thread = threading.Thread(
                    target=download_video, 
                    args=(video, SAVE_DIR),
                    name=f'{i} {video.title[:10]}',
                    daemon=True
                )
                video_thread.start()
        
        while threading.active_count() > 1:
            time.sleep(10)  # Clog main thread to prevent from early termination

    except Exception as e:
        logger_main.error(f"Critical Error: {e}. Program exiting.")
        print()  # Separate log messages and exception
        raise e
    
    logger_main.info('Finished running. Exiting...')

def retrieve_videos(playlist: Playlist, desc=True) -> Iterable[YouTube]:
    return list(playlist.videos)[::(-1 if desc else 1)]

def download_video(video: YouTube, save_dir: str, res='highest'):
    # Helper functions
    def file_exists(strict=False):
        filename = stream.default_filename if strict else safe_filename(stream.default_filename)+'.*'
        return glob.glob(os.path.join(save_dir, filename)) != []

    def skip_for_exists():
        """Important: This helper function assumes that the file already exists."""
        if ALWAYS_SKIP_ON_EXISTS or input(f'"{os.path.basename(save_dir)} already exists, overwrite? (y/N) "').lower() != 'y':
            logger_main.debug(f'{video.title} already exists. Skipping to the next video...')
            return True
        return False
    
    def check_file_integrity():
        """Checks local file size against approximated file size with a reasonable margin of error"""
        # Both in bytes:
        approx_size = stream.filesize_approx  # We do not request file size from server because that takes 100 years
        actual_size = os.path.getsize(os.path.join(save_dir, stream.default_filename))
        if approx_size - actual_size > 3072: # They normally have a difference of at least 1kiB. We use 3kiB here as threshold.
            return False
        else:
            return True
    
    def on_progress(stream_, chunk, bytes_remaining, bytes_total):
        """Displays progress logs when needed"""
        percent_completed = (1 - bytes_remaining / bytes_total) * 100
        if int(percent_completed) % 10 in (0, 1, 2):
            logger_main.debug(f'Progress {int(percent_completed)}%')

    # Function body
    try:
        logger_main.debug('Retrieving streams...')
        stream = video.streams.get_highest_resolution()  # Turns out this operation is not time-consuming
        # Check for integrity and duplicate files
        if CHECK_FILE_INTEGRITY:
            if file_exists(True):
                logger_main.debug('Checking file integrity...')
                if check_file_integrity() == False:
                    logger_main.debug(f'{stream.default_filename} exists but may be corrupted. Proceeding to overwrite...')
                else:
                    if skip_for_exists(): return
        else:
            if file_exists(False) and skip_for_exists(): return
        # Register progress logging
        video.register_on_progress_callback(
            lambda stream_, chunk, bytes_remaining :
                on_progress(stream_, chunk, bytes_remaining, stream.filesize_approx)
        )
        # Proceed to download video
        logger_main.info(f'Downloading {video.title}...')
        stream.download(save_dir, skip_existing=False)  # Filename is automatically generated by stream
    except VideoUnavailable:
        logger_main.warning(f'{video.title} not found. Skipping to the next video...')
        return
    except Exception as e:
        logger_main.error(f'Download aborted! Critical error when downloading {video.title}: {e}')
        return
    logger_main.info(f'Finished downloading {video.title}!')

if __name__ == "__main__":
    main()
